# 题目:
    给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

    找到所有出现两次的元素。

    你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？

# 示例:
    输入:
    [4,3,2,7,8,2,3,1]

    输出:
    [2,3]

# 思路
    1. 对每一个数，hash到数组下标,如果出现两次的数，那么当我们第二次遇见时nums[m -1]一定为负数
    2. 原地hash ，对当前的数做修改，要用时在改回来
    3. 标记数组
# 解答:
```c++
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> res;
        for(int num : nums) {
            int m = abs(num);
            if(nums[m-1] < 0)
                res.push_back(m);
            else{
                nums[m-1] = -nums[m-1];
            }
        }
        return res;
    }
};
```
```c++
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) 
    {
        int n=nums.size();
        for(int i=0;i<n;i++)
        {
            while(nums[i]!=nums[nums[i]-1])
                swap(nums[i],nums[nums[i]-1]);
        }     
        vector<int> res;
        for(int i=0;i<n;i++)
        {
            if(nums[i]!=i+1) //当前的值不在其hash上
                res.push_back(nums[i]);
        }   
        return res;
    }
};
```
```c++
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) 
    {
        int n=nums.size();
        for(int i=0;i<n;i++)
        {
            int index=(nums[i]-1)%n;
            nums[index]+=n;
        }
        vector<int> res;
        for(int i=0;i<n;i++)
        {
            if(nums[i]>2*n) //出现两次
                res.push_back(i+1);
        }
        return res;
    }
};
```

# 总结
    